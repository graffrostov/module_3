"""

[x] Создайте функцию send_email, которая принимает 2 обычных аргумента: message(сообщение),
[x] recipient(получатель) и 1 обязательно именованный аргумент со значением по умолчанию sender = "university.help@gmail.com".
[] Если строки recipient и sender не содержит "@" или не оканчивается на ".com"/".ru"/".net",
[] то вывести на экран(в консоль) строку: "Невозможно отправить письмо с адреса <sender> на адрес <recipient>".
[] Если же sender и recipient совпадают, то вывести "Нельзя отправить письмо самому себе!"
[] Если же отправитель по умолчанию - university.help@gmail.com, то вывести сообщение:
   "Письмо успешно отправлено с адреса <sender> на адрес <recipient>."
[] В противном случае вывести сообщение: "НЕСТАНДАРТНЫЙ ОТПРАВИТЕЛЬ!
[] Письмо отправлено с адреса <sender> на адрес <recipient>."
   Здесь <sender> и <recipient> - значения хранящиеся в этих переменных.
[] За один вызов функции выводится только одно и перечисленных уведомлений! Проверки перечислены по мере выполнения.

 String.partition(sep)
 Разделяет строку в месте первого вхождения заданного разделителя (sep) и возвращает кортеж из трех элементов:
 части строки до разделителя, самого разделителя и части строки после него.

 Если заданный разделитель не найден, метод опять же возвращает кортеж из трех элементов,
 где первым элементом будет вся неразделенная строка, за которой будут идти две пустые строки.
"""


# функция проверки корректности адреса отправителя и получателя
def check_string(recipient, sender):
    # Кортеж для проверки окончаний почтового адреса. Можно добавлять, например: .list, .org
    check_end = ('.ru', '.com', '.net')

    # на всякий случай приводим адреса для проверки к нижнему регистру
    recipient.lower()
    sender.lower()

    # Флаг. Проверяем наличие окончаний в почте получателя
    # True при наличии. False при отсутствии
    check_mail = recipient.endswith(check_end)

    # Проверим почту отправителя на соответствие окончаниям.
    # Проверим наличие символа @ в адресах.
    # Требуется ещё ряд проверок на соответствие, но в задании не указаны.
    # С помощью логического И сохраним значение флага, если хоть одно условие ложно
    check_mail = check_mail and sender.endswith(check_end)
    check_mail = check_mail and ('@' in (item for item in recipient))
    check_mail = check_mail and ('@' in (item for item in sender))

    # Возвращаем значение флага.
    return check_mail

# Функция отправки почты. Принимает два обязательных значения. Сообщение и получатель.
# Также содержит именованный необязательный параметр Отправитель.
def send_email(message, recipient, *, sender="university.help@gmail.com"):

    # Проверяем ящики на соответствие формату
    # Проверка провалена - сообщение о невозможности отправки
    if not check_string(recipient, sender):
        print('Невозможно отправить письмо с адреса', '"' + sender + '"', 'на адрес', '"' + recipient + '"')

    # Проверка на совпадение ящиков
    elif recipient == sender:
        print('Нельзя отправить письмо самому себе!')

    # Проверка на стандартного отправителя
    elif sender == 'university.help@gmail.com':
        print('Письмо успешно отправлено с адреса', '"' + sender + '"', 'на адрес', '"' + recipient + '"')

    # Все прочие случаи
    else:
        print('НЕСТАНДАРТНЫЙ ОТПРАВИТЕЛЬ! Письмо отправлено с адреса', '"' + sender + '"', 'на адрес',
              '"' + recipient + '"')


# Проверочные сообщения.
send_email('Это сообщение для проверки связи', 'vasyok1337@gmail.com')
send_email('Вы видите это сообщение как лучший студент курса!', 'urban.fan@mail.ru', sender='urban.info@gmail.com')
send_email('Пожалуйста, исправьте задание', 'urban.student@mail.ru', sender='urban.teacher@mail.uk')
send_email('Напоминаю самому себе о вебинаре', 'urban.teacher@mail.ru', sender='urban.teacher@mail.ru')
